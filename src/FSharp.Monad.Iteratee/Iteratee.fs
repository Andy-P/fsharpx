[<AutoOpen>]
module FSharp.Monad.Iteratee.Core

open System

/// A stream of chunks of data generated by an Enumerator.
/// The stream can be composed of chunks of 'a, empty blocks indicating a wait, or an EOF marker.
/// In Haskell, the Chunk is usually composed of a list of ListLike type, but F# doesn't support
/// Monad Transforms or ^M in type declarations. Thus, the Chunk is left open to various internal
/// types, but a bit more work must be done in order to maintain the meaningfulness of "chunk".
/// That said, the 'a allows a large number of chunk-y types to be used, including other monads.
/// Be aware that when using #seq<_> types, you will need to check for both Seq.empty ([]) and Empty.
type Stream<'a> =
  | Chunk of 'a
  | Empty
  | EOF

// TODO: Stream Monoid? I had this when using Chunk of 'a list, but trying to create a generic monoid appears impossible. I'll have to add multiple versions of everything in order to support such a construct. The Empty discriminator provides much of what was needed.

/// The iteratee is a stream consumer that will consume a stream of data until either 
/// it receives an EOF or meets its own requirements for consuming data. The iteratee
/// will return Continue whenever it is ready to receive the next chunk. An iteratee
/// is fed data by an Enumerator, which generates a Stream. 
type Iteratee<'el,'a> = Iteratee of Step<'el,'a>
and Step<'el,'a> =
  | Yield of 'a * Stream<'el>
  | Error of exn
  | Continue of (Stream<'el> -> Iteratee<'el,'a>)

/// An enumerator generates a stream of data and feeds an iteratee, returning a new iteratee.
type Enumerator<'el,'a> = Iteratee<'el,'a> -> Iteratee<'el,'a>

/// An Enumeratee is an Enumerator that feeds data streams to an internal iteratee.
type Enumeratee<'elo,'eli,'a> = Iteratee<'eli,'a> -> Iteratee<'elo, Iteratee<'eli,'a>>

[<AutoOpen>]
module Primitives =

  let runIter (Iteratee step) = step
  let returnI step = Iteratee step
  let yieldI x s = returnI <| Yield(x,s)
  let continueI k = returnI <| Continue k

  let bind m f =
    let rec innerBind m =
      Iteratee <|
        match runIter m with
        | Continue k -> Continue(innerBind << k)
        | Error e -> Error e
        | Yield(x, Empty) -> runIter (f x)
        | Yield(x, extra) ->
            match runIter (f x) with
            | Continue k -> runIter (k extra)
            | Error e -> Error e
            | Yield(acc',_) -> Yield(acc', extra)
    innerBind m

  let inline (>>==) (m:Iteratee<'a,'b>) (f:Iteratee<'a,'b> -> Iteratee<'c,'d>) = f m
  let inline (==<<) f m = m >>== f
  let inline (>==>) (e1:Enumerator<'a,'b>) (e2:Iteratee<'a,'b> -> Iteratee<'c,'d>) (s:Iteratee<'a,'b>) = e1 s >>== e2
  let inline (<==<) (e1:Iteratee<'a,'b> -> Iteratee<'c,'d>) (e2:Enumerator<'a,'b>) (s:Iteratee<'a,'b>) = e2 s >>== e1

  let throw e = returnI <| Error e

  let catchError h i =
    let rec step i = 
      match runIter i with
      | Yield(b, xs) -> yieldI b xs
      | Error e -> h e
      | Continue k -> continueI (fun s -> k s >>== step)
    in i >>== step

  let tryFinally compensation i =
    let rec step i = 
      match runIter i with
      | Continue k -> continueI (fun s -> k s >>== step)
      | i -> compensation(); returnI i
    in i >>== step

  let rec enumEOF i = 
    match runIter i with
    | Yield(x,_) -> yieldI x EOF
    | Error e -> throw e
    | Continue k ->
        match runIter (k EOF) with
        | Continue _ -> failwith "enumEOF: divergent iteratee"
        | i -> enumEOF <| returnI i
  
  let enumErr e = function _ -> Error e

  let run i =
    match runIter (enumEOF ==<< i) with
    | Error e -> Choice1Of2 e
    | Yield(x,_) -> Choice2Of2 x
    | Continue _ -> failwith "run: divergent iteratee"
  
  let run_ i =
    match run i with
    | Choice1Of2 e -> raise e
    | x -> x
  
type IterateeBuilder() =
  member this.Return(x) = Yield(x, Empty)
  member this.ReturnFrom(m:Iteratee<_,_>) = m
  member this.Bind(m, k) = bind m k
  member this.Zero() = yieldI () Empty
  member this.Combine(comp1, comp2) = bind comp1 <| fun () -> comp2
  member this.Delay(f) = bind (yieldI () Empty) f
  member this.TryWith(m, h) = catchError h m
  member this.TryFinally(m, compensation) = tryFinally compensation m
  member this.Using(res:#IDisposable, body) =
    this.TryFinally(body res, (fun () -> match res with null -> () | disp -> disp.Dispose()))
  member this.While(guard, m) =
    if not(guard()) then this.Zero() else
      this.Bind(m, (fun () -> this.While(guard, m)))
  member this.For(sequence:#seq<_>, body) =
    this.Using(sequence.GetEnumerator(),
               (fun enum -> this.While(enum.MoveNext, this.Delay(fun () -> body enum.Current))))
let iteratee = IterateeBuilder()

module Operators =
  let inline returnM x = yieldI x Empty
  let inline (>>=) m f = bind m f
  let inline (<*>) f m = f >>= fun f' -> m >>= fun m' -> returnM (f' m')
  let inline lift f m = m >>= fun x -> returnM (f x)
  let inline (<!>) f m = lift f m
  let inline lift2 f a b = returnM f <*> a <*> b
  let inline ( *>) x y = lift2 (fun _ z -> z) x y
  let inline ( <*) x y = lift2 (fun z _ -> z) x y
  let inline (>>.) m f = m >>= (fun _ -> f)
