{"google":"","body":"FSharpx\r\n=======\r\n\r\n**FSharpx** is a library for the .NET platform implementing general functional constructs on top of the F# core library. \r\nIts main target is F# but it aims to be compatible with all .NET languages wherever possible.\r\n\r\nIt currently implements:\r\n\r\n * Several standard monads: State, Reader, Writer, Either, Continuation, Distribution\r\n * Purely functional data structures: Queues, double-ended Queues, BottomUpMergeSort, RandomAccessList, Vector, RoseTree\r\n * Validation applicative functor\r\n * General functions like flip\r\n * Additional functions around collections\r\n * Functions to make C# - F# interop easier\r\n * Async and Observable extensions\r\n\r\n\r\nF# Async Extensions\r\n===================\r\n\r\nThis library implements various extensions for asynchronous programming \r\nusing F# asynchronous workflows and F# agents (the `MailboxProcessor` type\r\nin the standard F# library). It defines _asynchronous sequences_ that represent\r\nasynchronous operations returning multiple values (such as reading data from\r\na stream in chunks), several reusable F# agents and numerous extensions.\r\n\r\n * Samples that demonstrate how to use most of the extensions can\r\n   be found in the [samples directory][7]\r\n\r\nAsynchronous sequences\r\n----------------------\r\n\r\nAsynchronous sequences can be used to work with asynchronous computations that return\r\nmultiple results. A value of type `AsyncSeq<'T>` can be started (just like an asynchronous \r\nworkflow) and it eventually returns. The result is either a special value representing\r\nthe end of the sequence or a value of type `'T` (head) together with the rest of the \r\nasynchronous sequence (tail) of type `AsyncSeq<'T>`.\r\n\r\nUnlike `IObservable<'T>`, asynchronous sequences are not _push-based_. The code that \r\ngenerates the next value of the asynchronous sequence starts only after previous elements\r\nhave been processed. This makes it possible to easily write computations that return\r\nresults as long as some component is using them. \r\n\r\nHowever, `IObservable<'T>` values can\r\nbe converted to asynchronous sequences. The `AsyncSeq.ofObservable` combinator creates an\r\nasynchronous sequence that discards values produced by the observable while the \r\nasynchronous sequence was blocked. The `AsyncSeq.ofObservableBuffered` combinator stores\r\nall produced values in an unbounded buffer and returns the values from the buffer as soon\r\nas the user of asynchronous sequence requestst the next element.\r\n\r\nThe library defines an F# computation expression for workfing with asynchronous sequences.\r\nFor example, sequence that emits numbers in 1 second intervals can be defined as follows:\r\n\r\n    let rec numbers n = asyncSeq {\r\n      yield n\r\n      do! Async.Sleep(1000)\r\n      yield! numbers (n + 1) }\r\n\r\nAsynchronous workflows and asynchronous sequences can use the `for` construct to iterate\r\nover all elements of an asynchronous sequence. For example:\r\n\r\n    let rec evenNumbers = asyncSeq {\r\n      for n in numbers 0 do\r\n        if n%2=0 then yield n }\r\n\r\nThe library also provides numerous combinators (similar to functions from the `Seq` module).\r\nThe result of operations that aggregate values of an asynchronous sequence is an asynchronous\r\nworkflow that returns a single value:\r\n\r\n    let rec sumTenEvenSquares = \r\n      numbers 0\r\n      |> AsyncSeq.filter (fun n -> n%2 = 0)\r\n      |> AsyncSeq.map (fun n -> n*n)\r\n      |> AsyncSeq.fold (+) 0\r\n\r\n    let n = \r\n      sumTenEvenSquares \r\n      |> Async.RunSynchronously\r\n\r\nFor some examples that use (earlier versions) of asynchronous sequences, see also the following\r\ntwo F# snippets: [first][5] and [second][6].\r\n\r\nReusable agents\r\n---------------\r\n\r\nThe library implements several reusable agents for building concurrent applications:\r\n\r\n * **Agent** is a simple type aliast for `MailboxProcessor` that is more convenient to use\r\n\r\n * **AutoCancelAgent** wraps the standard F# agent and adds support for stopping of the\r\n   agent's body using the `IDisposable` interface (the type automatically creates a \r\n   cancellation token, uses it to start the underlying agent and cancels it when the agent \r\n   is disposed). For example, [see this F# snippet][1].\r\n\r\n * **BatchProcessingAgent** can be used to implement batch processing. It creates groups of \r\n   messages (added using the `Enqueue` method) and emits them using the `BatchProduced` \r\n   event. A group is produced when it reaches the maximal size or after the timeout elapses.\r\n\r\n * **BlockingQueueAgent** implements an asynchronous queue with blocking put and blocking \r\n   get operations. It can be used to implement the _producer-consumer_ concurrent pattern. \r\n   The constructor of the agent takes the maximal size of the buffer.\r\n\r\n\r\nObservable extensions\r\n---------------------\r\n\r\nThe library implements extensions for using `IObservable<'T>` type from F# asynchronous \r\nworkflows. An overloaded extension method `Async.AwaitObservable` can be used to wait \r\nfor an occurrence of an event (or other observable action):\r\n\r\n    let counter n = async {\r\n      printfn \"Counting: %d\" n\r\n      let! _ = form.MouseDown |> Async.AwaitObservable\r\n      return! counter (n + 1) }\r\n\r\nOverloaded version of the method allows waiting for the first of multiple events. The \r\nmethod asynchronously returns `Choice<'T1, 'T2>` value that can be used to determine \r\nwhich of the events has occurred.\r\n\r\nFor examples using this method see Chapter 16 of [Real World Functional Programming][2] \r\n(some examples are available in a [free excerpt from the chapter][3]). The \r\n`Async.AwaitObservable` method should be used instead of `Async.AwaitEvent` to avoid \r\nmemory leaks (see also related [StackOverflow discussion][4])\r\n\r\n\r\nType Providers\r\n---------------------\r\n\r\nFSharpx provides some very interesting F# type providers. At the moment we have:\r\n\r\n * FSharpx.TypeProviders.AppSettings which generates setters and getters for application settings files.\r\n * FSharpx.TypeProviders.Documents which allows strongly typed access to JSON, XML and CSV files.\r\n * FSharpx.TypeProviders.Excel which provides strongly typed access to Excel spread sheets.\r\n * FSharpx.TypeProviders.Graph which includes type providers for state machines and graphs.\r\n * FSharpx.TypeProviders.Math which contains a type provider for vector data structures.\r\n * FSharpx.TypeProviders.Regex which allows to access regular expressions in a strongly typed manner.\r\n * FSharpx.TypeProviders.Machine which provides strongly typed access to the Registry and the file system.\r\n * FSharpx.TypeProviders.Xaml which includes a type provider for XAML files and therefor enables to use Visual Studiosâ€™s WPF Designer from F#.\r\n * FSharpx.TypeProviders.Freebase which allows to access the Freebase database with strong typing.\r\n\r\nAt the moment all type providers should work with .NET 4.0 and .NET 4.5 and F# 3.0.\r\n\r\nIn order to build and test the type providers do the following:\r\n\r\n * Open FSharpx.WithTypeProviders.sln with Visual Studio 2012\r\n * Set FSharpx.TypeProviders as startup project\r\n * In the properties of FSharpx.TypeProviders:\r\n   * Set the start action to \"external program\" and \"C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\Common7\\IDE\\devenv.exe\"\r\n   * Set the command line argument to \"C:\\code\\fsharpx\\FSharpx.TypeProviders.Tests.sln\" (adjust the path to match to your system)\r\n * Run the project --> A new Visual Studio 2012 instance should opened with FSharpx.TypeProviders.Tests.sln\r\n\r\n\r\nBuilding the project\r\n-----------------------\r\n\r\nRead the wiki page about [Build](https://github.com/fsharp/fsharpx/wiki/Build)\r\n\r\n  [1]: http://fssnip.net/64\r\n  [2]: http://manning.com/petricek\r\n  [3]: http://dotnetslackers.com/articles/net/Programming-user-interfaces-using-f-sharp-workflows.aspx\r\n  [4]: http://stackoverflow.com/questions/3701861/wait-for-any-event-of-multiple-events-simultaneously-in-f\r\n  [5]: http://fssnip.net/1k\r\n  [6]: http://fssnip.net/1Y\r\n  [7]: http://github.com/fsharp/fsharpx/tree/master/samples\r\n","tagline":"Extensions and Tools for F# Programming","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Fsharpx"}